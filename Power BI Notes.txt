Power BI
-----------
- A Business Intelligence tool by Microsoft
- The most used analytical tool in the world

Two components of Power BI
---------------------------
Power BI Service:
	- Collaborate and work with others
	- Share your work with others based on roles
	- Cloud storage
	- Advanced analytics
Power BI Desktop:
	- Free desktop application
	- Do all the analytics on this

Download Power BI Desktop


Three types of objects in Power BI
------------------------------------
- Table
- Column
- Measure

From Table we get Columns -> Measure or based on Tables and Columns

We can create the above objects using DAX formulas (in the Formula Bar)

DAX -> Data Analysis eXpressions
	- code (formulas)
	- appear like Excel formulas


DAX Formulas
=============
Syntax for DAX:

Name = Formula

Name refers the name of the object you are creating:
	Table
	Column
	Measure

Formula is a DAX expression to create the object.

Referring objects in Formulas:
Table:		TableName
Column:		[ColumnName]	or TableName[ColumnName]
Measure:	[Measure]


Creating a Date Table using DAX expression: Calendar
----------------------------------------------------
Name = Formula

Calendar = Formula

What does the Calendar table contain?
- Sequence of dates as in a calendar

Calendar = CALENDAR( start_date, end_date )
	- CALENDAR() generates sequence of dates

DATE formula: Returns a date value
	DATE( year, month, day )
	DATE( 2026, 1, 26)
	DATE(2026, 4, 20)
	DATE(2026, 11, 17)
	DATE(2026, 8, 2)

Calendar = CALENDAR( 
		DATE(2017, 1, 1), 
		DATE(2019, 12, 31) 
)

Calendar	-> Table name
		-> By default, column with dates is named Date

Choose 'New Table' and paste the above formula in the Formula Bar


Types of DAX Formulas
=======================
- Calculated Columns
- Measures

Calculated Column
-----------------
- Using a DAX formula to create a column (in a table)


Date Components:
2026/1/26
	Year: 2026
	MonthNum: 1
	Month: January
	Day: 26
	WeekdayNum: 2 (Sun-Sat: 1 to 7)
	Weekday: Monday
	WeekNum: 5 (53 weeks)


FORMAT( value, format_code )
	Formats the given value
	value -> date
	format -> January, February, March, ...

FORMAT( [Date], format_code )

format codes:
	yyyy	-> four digit year number
	yy	-> two digit year number
	m	-> month number (1, 2, 3, ..., 11, 12)
	mm	-> month number (01, 02, 03, ..., 11, 12)
	mmm	-> short month name (Jan, Feb, Mar, ...)
	mmmm	-> full month name (January, February, March..)
	d	-> day number (1, 2, 3, ..., 30, 31)
	dd	-> day number (01, 02, 03, ..., 30, 31)
	ddd	-> short day name (Sun, Mon, Tue, ...)
	dddd	-> full day name (Sunday, Monday, ...)


Name = Formula
Month = FORMAT( [Date], "MMMM" )

Choose 'New Column' and paste the formula in Formula Bar



Name = Formula
Year = YEAR( date_value )

YEAR( date_value )
	Returns the year number from the date value.

Year = YEAR ( [Date] )

Choose 'New Column' and paste the formula in Formula Bar



Name = Formula
MonthNum = Formula

Formula: MONTH( date_value )
	- Returns month number

MonthNum = MONTH ( [Date] )



WeekNum
============
There are 53 weeks (1 - 53)

Name = Formula
WeekNum = WEEKNUM( date_value )
WeekNum = WEEKNUM( [Date] )


Weekday
=======
Name = Formula
Weekday = FORMAT( date_value, format_code )
Weekday = FORMAT( [Date], "DDDD" )


WeekdayNum
============
Name = Formula
WeekdayNum = WEEKDAY( [Date] )
		Sun -1, Mon -2, Tue -3, ..., Sat -6

WeekdayNum = WEEKDAY( [Date], 2 )
		Mon 1, Tue 2, Wed 3, ..., Sun 7
		Mon - Fri (1 - 5)
		Sat - Sun (6 - 7)

WeekdayNum = WEEKDAY( [Date], 3 )
		Mon 0, Tue 1, Wed 2, ..., Sun 6



2017, 2018, 2019 - Numbers - Text

2017, 2018, 2019



1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 - Numbers

1, 10, 11, 12, 2, 3, 4, 5, 6, 7, 8, 9 - Text







IsWorkday
=========
Mon - Fri	-> 1
Sat - Sun	-> 0


= IF ( condition, if_true, if_false )
	True/False

IsWorkday = Formula
IsWorkday = IF( [WeekdayNum] <= 5, 1, 0 )



Calculations
****************
- Calculated Columns
	- create a column in a table using a DAX calculation
	- It uses a 'row context'
- Measures



Calculated Columns
---------------------
Hours table:

Column = SUM( [Hours] )
	- Resets the function for 'filter context'

Don't use aggregate functions to create 'Calculated Columns', functions such as: SUM, AVERAGE, MEDIAN, MAX, MIN, COUNTA


Column 2 = [Hours] / [TotalHours]
	applies 'row context'



Utilization Target 80%
	Total Billable Hours / Total Hours
		= 0.8 (80%)


Column 3 =
SUMX(
	FILTER(
		ALL('Hours'),
		[Category] = "Billable" && [EmployeeID] = EARLIER( [EmployeeID] )
	),
	[Hours]
)


EARLIER() function works in 'row context'
	it executes for each row

ALL() -> Removes all the filters from the table/column/expression

Filters are of 3 types: Filter Context
	- visual
	- slicer
	- from filters pane



Total Hours = SUM( 'Hours'[Hours] )

Total Rows = COUNTROWS( 'Hours' ) 
Grand Total Rows = COUNTROWS( ALL ( 'Hours' ) )


Column 3 =
SUMX(
   FILTER( ALL('Hours'),
	   [Category] = "Billable" && [EmployeeID] = EARLIER( [EmployeeID] )
	),
	[Hours]
)



FILTER() function
===================
FILTER( table, filter1, filter2, filter3, ... )

	- Creates a virtual table


Iterator Functions
======================
SUMX, AVERAGEX, MINX, MAXX, COUNTAX, ... These functions are called iterators.

Most iterator functions end with the letter 'X'
Some iterator functions don't end with letter 'X'
There are non-iterator functions which also end with letter 'X'

Syntax:

FUNCTION_NAME( table, expression )
	expression is evaluated for each row of the table

SUMX( table, expression )
	expression is evaluated for each row of the table and then sums all the values.


Invoices
Agent	Sales
-----	-----
A	10
B	20
C	30

SUM( [Sales] )	 or 	SUM( 'Invoices'[Sales] )
	60

SUMX ( 'Invoices', 'Invoices'[Sales] * 1.5 )
	10 * 1.5	15
	20 * 1.5	30
	30 * 1.5	45

			90

AVERAGEX ( 'Invoices', 'Invoices'[Sales] * 1.5 )
	30


	Total Billable Hours / Total Hours
		Utilization



Column 4 =
SUMX(
   FILTER( ALL('Hours'),
	   [EmployeeID] = EARLIER( [EmployeeID] )
	),
	[Hours]
)


Column 5 = [Column 3] / [Column 4]
Column 5 = DIVIDE( [Column 3], [Column 4], 0)



Budgets and Forecasts
=======================
New Column

MonthYear = [Month] & "2017"

& - Concatenation operator


Calendar
=========
New Column

MonthYear = LEFT( [Month], 3) & [Year]


New Table
=========
MonthYears = DISTINCT( 'Calendar'[MonthYear] )


Calendar table granularity is day-wise
Budgets and Forecasts table granularity is month-wise


Measures
============
- Measure are evaluated in a visual.
- Measure is filtered by visual, slicer, filters pane, and filters in the expressions.


Total Billable Hours = 
SUMX(
	FILTER( 'Hours', 'Hours'[Category] = "Billable" ),
	'Hours'[Hours]
)


% Utilization = Total Billable Hours / Total Hours


Rajkumar (week)
	day1 8 hours (billable) 8
	day2 8 hours (billable) 8
	day3 6 hours (Training) 8 
	day4 7 hours (Int. Admin) 8
	day5 3 hours (sales report) 8

16 billable hours
32 reported hours
40 total hours
16 / 32 (0.5) => 50%
16 / 40 => 40%


Creating WorkHours column in Calendar table:

WorkHours = IF( [IsWorkday], 8, 0 )
WorkHours = IF( [IsWorkday] = 1, 8, 0 )


Total Hours Measure:

Total Hours = SUM( 'Calendar'[WorkHours] )


Name		Total Billable Hours		Total Hours
-------		---------------------		-----------
People	-> 	Hours			<-	Calendar
1990 - 2017	2019 (Jan - Mar)		2017 - 2019


ID		EmployeeID
A		A


All Names		------			All Hours (6256)



People	-> 	Hours			<->	Calendar
1990 - 2017	2019 (Jan - Mar)		2019 (Jan - Mar)


% Utilization = [Total Billable Hours] / [Total Hours]

% Utilization = DIVIDE( [Total Billable Hours] , [Total Hours] , 0)


Rename [Total Hours] -> [Total Hours by Employee]

The [% Utilization] measure is automatically updated:

% Utilization = 
DIVIDE( [Total Billable Hours] , [Total Hours by Employee] , 0)




New measure named: [Total Hours]

Total Hours =
IF(
	HASONEVALUE(People[Name]),
	[Total Hours by Employee],
	SUMX(
		SUMMARIZE(
			'People', People[Name],
			"__Hours", [Total Hours by Employee]
		),
		[__Hours]
	)
)


People
-------------
Name		__Hours
-------		--------
Shanmukh	70
Santosh		30
Rajkumar	55
Jagadeesh	45



Update % Utilization:

% Utilization = 
DIVIDE( [Total Billable Hours] , [Total Hours] , 0)


When the [% Utilization] measure is sorted in ascending order in the visual, we see the blank values in the column of the visual.
So, lets update the % Utilization measure


% Utilization =
VAR __utilization = 
	DIVIDE( [Total Billable Hours] , [Total Hours] , 0)
RETURN
    __utilization + 0


The above expression add more rows because its showing previous employees.


Update the formula:
-------------------
% Utilization =
VAR __utilization = 
	DIVIDE( [Total Billable Hours] , [Total Hours] , 0)
VAR __days = COUNTROWS('Hours')
RETURN
IF(
	ISBLANK(__days),
	BLANK(),
	__utilization + 0
)



SWITCH(	expr,
	value1, result1,
	value2, result2,
	value3, result3,
	...
	default_result
)



Total Hours =
SWITCH( MAX(People[EmployeeType]),
	"HOURLY", [Total Billable Hours],
	"SUB-CONTRACTOR", [Total Billable Hours],
	"SALARY", IF( HASONEVALUE(People[Name]),
			[Total Hours by Employee],
			SUMX(
			SUMMARIZE(
			'People', People[Name],
			"__Hours", [Total Hours by Employee]
			),
			[__Hours]
			)
	),
	BLANK()
)





Division -> JobID -> Hours



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Customer Name = RELATED( Customers[CUSTOMER NAME] )

Region Name = RELATED( Regions[REGION] )


Two conditions for using REALTED function:
- 1. Tables must be realted4
- 2. We can use this is the table which is on many side (not on one side). We can get the data from one side into many side, but not vice-versa.



Measures
----------
Total Units = SUM ( Productsales[UNITS SOLD] )
Avg Units = AVERAGE( Productsales[UNITS SOLD] )

No. of Sales = COUNTROWS ( Productsales )
	- counts all the rows in a table

Avg Units 2 = [Total Units] / [No. of Sales]

Distinct Customers = DISTINCTCOUNT ( Productsales[CUSTOMER ID] )
	- counts unique values from a column


Total Stores = SUM ( Customers[NO. OF STORES] )

No. of Products = COUNTROWS ( Products )



CALCULATE
----------------
Syntax:

= CALCULATE ( expression, filter1, filter2, filter3, ... )
expression -> measure or a calculated column formula
CALCULATE modifies the filter context of the expression

By default, filters in CALCULATE() function are combined using AND (&&) operator.

There is OR (||) operator.


[Total Units] -> all years 2017 - 2021


2021 Units =
CALCULATE ( [Total Units], DateTable[YEAR] = 2021 ) 


2021 Percentage =
DIVIDE ( [Total Units] , [2021 Units], 0 )



UnitPrice = RELATED( Products[PRICE PER UNIT] ) 

TotalSales = [Units Sold] * [UnitPrice]


Total Sales = SUM( Productsales[UNITS SOLD] * Products[PRICE PER UNIT] )

Total Sales =
SUMX( Productsales,
	Productsales[UNITS SOLD] * RELATED ( Products[PRICE PER UNIT] )
)	


Total Sales Greater than 350 =
CALCULATE ( [Total Sales], Productsales[UNITS SOLD] > 350 )


Total Units in May 2021 = 
CALCULATE ( [Total Units],
		DateTable[YEAR] = 2021,
		DateTable[MONTH] = "may"
)


Total Units for Abel in Argentina =
CALCULATE ( [Total Units],
		SalesPeople[SALESPERSON] = "Abel",
		Regions[REGION] = "Argentina"
)


Average Units for Black Ltd in 2021 =
CALCULATE ( AVERAGE ( Productsales[UNITS SOLD] ) , 
	Customers[CUSTOMER NAME] = "black ltd",
	DateTable[YEAR] = 2021
)



Combing two filters using OR (||) operator on the same column gives correct results:


Total Units in 2020 or 2021 =
CALCULATE ( [Total Units],
	DateTable[YEAR] = 2021 || DateTable[YEAR] = 2020
)			


Average Units for Argentina or Australia =
CALCULATE ( AVERAGE ( Productsales[UNITS SOLD] ),
Regions[REGION] = "Argentina" || Regions[REGION] = "Australia"
)

Average Units for Argentina or Australia 2 =
CALCULATE ( AVERAGE ( Productsales[UNITS SOLD] ),
Regions[REGION] = "Argentina", Regions[REGION] = "Australia"
)



Combing two filters using OR (||) operator on the different columns gives incorrect results:

Sales for Red or France =
CALCULATE ( [Total Sales],
	Products[TYPE] = "Red" || Products[PRODUCT COUNTRY] = "France")


Sales for Red or France 2 =
CALCULATE ( [Total Sales],
	Products[TYPE] = "Red", Products[PRODUCT COUNTRY] = "France")


Sales for Red or France 3 =
CALCULATE ( [Total Sales],
	FILTER (Products,
		Products[TYPE] = "Red" || Products[PRODUCT COUNTRY] = "France")
)



No. of Sales = COUNTROWS ( Productsales )

No. of Sales greater than 350 =
COUNTROWS (
	FILTER ( Productsales,
		Productsales[UNITS SOLD] > 350 )
)


No. of Sales of High Profit Products =
CALCULATE ( [No. of Sales],
	FILTER ( Products,
		Products[PRICE PER UNIT] >= 3 * Products[COST PRICE]
	)
)


NOTE: Always try to use FILTER() inside the CALCULATE() function when you need to filter a table.



Hours for Hours =
CALCULATE ( 
	SUM( 'Hours'[Hours] ),
	'Hours'[PayType] = "HOURLY"
)


Measure:
% Target Utilization = 0.8

Table:
Target Utilization = GENERATESERIES(50, 100, 5)


Calendar =
CALENDAR ( MIN ( 'Hours'[Date] ), MAX ( 'Hours'[Date] ) )


Division Title =
	VAR allCount = 3
	VAR currentCount = COUNTROWS ( SUMMARIZE ('Hours', [Division] ) )
RETURN
	SWITCH( TRUE(),
		HASONEVALUE(Hours[Division]), MAX(Hours[Division]),
		allCount = currentCount, "All Divisions",
		"Multiple Divisions"
)


Branch Title =
	VAR allCount = 3
	VAR currentCount = COUNTROWS ( SUMMARIZE ('People', [Location] ) )
RETURN
	SWITCH( TRUE(),
		HASONEVALUE(People[Location]), MAX(People[Location]),
		allCount = currentCount, "All Branches",
		"Multiple Branches"
)




tmpTable = DISTINCT( 'Hours'[Category] )


Type Title =
	VAR allCount = 3
	VAR currentCount = COUNTROWS ( SUMMARIZE ('People', [EmployeeType] ) )
RETURN
	SWITCH( TRUE(),
		HASONEVALUE(People[EmployeeType]), MAX(People[EmployeeType]),
		allCount = currentCount, "All Type",
		"Multiple Types"
)




Employee Type =
IF (	HASONEVALUE( 'People'[Name] ),
		MAX( 'People'[Name] ),
		"Multiple Employees"
)



MS EXCEL
~~~~~~~~~~~~
- World's number of spreadsheet application


Cell References
================
A5	-> Column A, Row 5
M14	-> Column M, Row 14

1. Relative references:
	A relative reference is a position, not an address
	A5, M12, G7, C15, B4, ....

2. Absolute references:
	An absolute reference is an address
	$A$5, $M$12, $G$7, $C$15, $B$4, ....

3. Mixed references
	Column absolute, Row relative:
	$A5, $M12, $G7, $C15, $B4

	Column relative, Row absolute:
	A$5, M$12, G$7, C$15, B$4



Referring Cells from another sheet:
=SheetName!CellsAddress
=Sheet1!A5
=Sheet2!$B$8

Referring cells from another workbook:
=[Forecast.xlsx]Sheet1!A9



LOOKUP FORMULAS
~~~~~~~~~~~~~~~~~~

=VLOOKUP( lookup_value, table_array, col_index, [type] )

lookup_value: is the search value which is searched in the first column of the table_array

table_array: is a table with atleast two columns, that's what makes sense

col_index: the column from which you want the output from the table_array

[type]: optional; type of lookup:
	0 (False): exact match
	1 (True): approximate match (ascending order)
		Exact or less than
	-1: approximate match (descending order)


=IFERROR( expression, output )
	IF the expression returns an error, then the outcome is 'output' value
	Otherwise, the outcome is from the expression.




=INDEX( table_array, row_num, column_num )
	Returns value from the table_array based on the row_num and col_num specified.



=MATCH( lookup_value, column-or-row_array, [type] )

Searches for lookup_value in the specified row/column.

[type]: optional; type of lookup:
	0 (False): exact match (random order)
	1 (True): approximate match (ascending order)
		Exact or less than
	-1: approximate match (descending order)
		Exact or greater than



=LOOKUP( lookup_value, lookup_array, pickup_array )

Search for the position_number of 'lookup_value' in the 'lookup_array'. Then it returns the value from the same position from 'pickup_array'.

Note: lookup_array and pickup_array should have same number of cells.



=xLOOKUP( lookup_value, lookup_array, pickup_array, "Default value", [type] )

0	exact match (random values)
1	approximate (exact or less than)
-1	approximate (exact or greater than)
2	wild cards
		?	one character
		*	zero to any number of characters





=IF( B2 < LARGE($B$2:$B$13,3), NA(), B2 )

=IF( B2 < LARGE($B$2:$B$13,3), B2, NA() )



=IF( B2 < LARGE($B$2:$B$13,$D$2), NA(), B2 )

=IF( B2 < LARGE($B$2:$B$13,$D$2), B2, NA() )




